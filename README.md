# Full Stack Open Seminar - University of Helsinki<br/>

## About <br/>
This repository is created for the needs of Full-Stack-Open Seminar of University of Helsinki. The course covers MERN Stack topics from easy to advanced level, organized in 14 parts. Parts 0-5 are the core of the course, while every of the next parts is an extension of the core course. Inside each folder of this repository there are all the exercises of the course demanded for a full-point certificate. The course has as prerequisites solid knowledge of HTML, CSS and Javascript, how git and github work and basic concepts of programming. 

## Part 0 - Fundamentals of Web Development
This part is an introduction of how web applications work. Through **Mermaid-Syntax diagrams** the relationship between user, browser and server is depicted. In addition, the evolution from traditional to modern SP applications is presented. Hence, the *3 exercises* include:<br/>
-A diagram showing how a page loads in an SPA<br/>
-A diagram showing how a note is made in a note SPA<br/>
-A diagram showing how a note is made in a traditonal note app <br/>

## Part 1 - Introduction to React
In this part the fundamentals of React are presented. There is a thorough explanation of **JSX**, **State Variables**, **Event Handlers** and **component organization** of a web application's frontend. Also, there is an introduction on how **debugging** works on the frontend. These concepts are practically issued in the *3 exercises* in the Part 1 folder.<br/>

## Part 2 - Communication with the Server
This part covers how the browser communicates with the server through **Axios** library of **npm** and **JSON Server**. The concepts issued here is **rendering a collection**, how our code can be tidied up with **modules** and how we can use **Forms** for collecting data. We should not ommit the introduction to how **promises** work in asynchronous functions and the need of **Effect-hooks**. Basically, this part deepens on how **getting, sending and altering data to server** works in real web Apps. Finally, there is a reference on how **styling** apps works in React. <br/>

## Part 3 - Programming a Server with NodeJS and Express
This part is focused on the backend of web Applications, using **NodeJS** and **Express** library. Firstly, there is an analysis of **RESTful** applications, whereas there is a solid explanation of the **middleware** importance and usage, especially working with **Morgan** Tokens. Afterwards, the **Cors** library is presented for connecting frontend with backend and again, how debugging works, this time in backend. Familiriazation with tools such as **Postman** begins. How to use **Render** for app deployment in the internet and how **MongoDB** works are also in the list. Lastly, the tool **ESLint** is used for syntax errors.

## Part 4 - Testing Express Servers, User Administartion
**Testing Environment**, **Supertest** library, and **error-handling** are the basic concepts of this part. We learn how to use **async/await** syntax, eliminating try/catch syntax and how to **organize tests** with descibe and test-only. The tests are implemented to check the functionality of User Administartion, API Calls and information saved to MongoDB Atlas database. Also, **User administration, authorization and authentication** are referred to, implementing the **JWT Strategy** in a bloglist app.

## Part 5 - Testing React apps
In this part we implement the frontend of a login page and we first use **Local Storage**. We learn about **children components** and **Prop-Types**. We test our bloglist app about its frontend. **Debugging**, **snapshot tests**, **E2E testing(Playwright and Cypress).**

## Part 6 - Advanced State Management
This part of the course focuses on how we manage **states** in a React applications. So far, we used **useState hook** to manage the changes in the application's state, even though this is not the optimal way, especially when apps are getting more complicated. Therefore, we first learned about **Flux architecture** and we used **Redux** library to face state management at its whole. That's why we learned about **store**, **actions** and **reducers**. We implemented **uncontrolled forms** and we simplified our App.jsx component by implementing **action creators** to diverse the actions' types and forms from components. In other words, app's state is independent from the frontend. We also used the **Redux Toolkit** to combine reducers and finally we connected the backend (JSON Server) with thw frontend thanks to axios and **Redux Thunk** library. Finally, we learned about **React-Query library**, another way to manage applications' states. 

## Part 9 - TypeScript
This part is an extension of the core course. After being familiarized with the **background**, **pros** and **cons** of TypeScript, we learn the **syntax** and **properties** of TypeScript, like **type narrowing** and **assertion**, by creating simple calculator applications. We combine **TypeScript with express** to set up servers and API calls. For this reason we learn about **utility types**, **validation**, **type guards** and the schema validation library **zod**. Also, we combine **TypeScript with React** to create the frontend of an application, like we did with pure Javascript in the core course. In the end of this part we buil the **Patientor** application, which shows a patient list, enables adding patients of various types and patient entries. For styling, we also use **MaterialUI**. 

## Part 11 - CI/CD
In this part we learnt about Continuous Integration and Continuous Deployment/Development. The part begins with the comparison between **self-hosted** setups and **cloud-based** ones for our CI setup. For the needs of the course, we used **Github Actions**, which is cloud-based, seeing that our application (Pokedex) is relatively simple. Starting with Github Actions, we created some simple **workflows**, and begun with **linting**, **testing** and **building**. The testing framework we used, in contrast to previous parts which proposed **Vitest**, is **Jest**. Also, we executed some **E2E** tests with **Playwright**. In addition, we **manually deployed** our application in **Render**, we created a **shell script** to run several building and start commands and later on we **automated** our deployment using **deploy hook** and we integrated some **"Health checks"** to ensure that our application works without breaking. We worked with **pull requests** and permitted deployment only on push requests, using if statements in our workflows. Finally, we used **Github Tokens** to add **semantic versioning** to our application and we created **protection** to our main branch by creating ruleset to Github. Taking into consideration that this part's repository was forked for the demands of the course, the link is the following: [CI/CD Repository](https://github.com/BarbaraKoul/full-stack-open-pokedex) . In this Repository (Full-Stack-Open), you will find a folder named "Part11", which includes the first exercise of Part 11. This exercise was an introduction of how CI/CD process works on different programming languages.  
